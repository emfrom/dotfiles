#+TITLE: Bash config for emfrom
#+AUTOR: E.M. From
#+PROPERTY: header-args:shell :tangle ./bashrc :mkdirp yes
#+STARTUP: overview

*Init files for bash*

This file generates all the bash files, even the empty ones. It creates wrappers for the real files in the HOME directory. I dont know if this is a smart move but it works and minimizes clutter

Main target is [[file:bashrc][bashrc]]
bashrc is called from inside [[file:bash_profile][bash_profile]] for a login shell

[[file:bash_logout][bash_logout]] is called when a login shell exits

There are several main files that reside in the etc/bash directory, that are called by bashrc directly
They are (in order) [[file:options][options]], [[file:aliases][aliases]], [[file:functions][functions]] & [[file:completions][completions]]

Data to setup colours for ls, via the variable LS_COLORS, is contained in the file dircolours
It is also tangled as a file from [[Dircolours][dircolours]]

* Bash profile
** Wrapper in HOME
*** Intro
Some info at the start of the file

#+begin_src shell :tangle ~/.bash_profile :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bash_profile
  #

  #
  # This is the calling wrapper for .bash_profile
  # The actual bash_profile resides in etc/bash
  #

#+end_src

*** Call bash_profile

#+begin_src shell :tangle ~/.bash_profile :mkdirp yes

  #
  # Do nothing
  # except call bash_profile if it exists
  #
  if [[ -f "${HOME}/etc/bash/bash_profile" ]] ; then
      source "${HOME}/etc/bash/bash_profile"
  fi

#+end_src


** Intro
Some info at the start of the file

#+begin_src shell :tangle ./bash_profile :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bash_profile
  #

  #
  # This is the .bash_profile startup scritp for bash login shells
  #
  # The whole login shell thing is an idiotic notion,
  # but I suppose it made sense at some point in unix time
  #

#+end_src

** Debug echo

For debugging purposes
Just knowing which file is sourced and when is usually all that is needed to debug bash startup and finish stuff

#+begin_src shell :tangle ./bash_profile :mkdirp yes
  #
  # Echo for debugging purposes
  #(this is very useful on some systems)
  #

  echo ".bash_profile sourced (this is a login shell)"

#+end_src
** Call bashrc
Both .profile and .bash_profile should do nothing other than call .bashrc

#+begin_src shell :tangle ./bash_profile :mkdirp yes

  #
  # call .bashrc if it exists
  #
  if [[ -f "${HOME}/etc/bash/bashrc" ]] ; then
      source "${HOME}/etc/bash/bashrc"
  fi

#+end_src




** Last things
**** clear
Not doing this since motd contains actual info on some systems

#+begin_src shell :tangle ./bash_profile :mkdirp yes
  #
  # Some breathing room
  #
  #cls

#+end_src
**** ansi_heart
#+begin_src shell :tangle ./bash_profile :mkdirp yes

  # && ansi_heart
#+end_src

**** figlet
#+begin_src shell :tangle ./bash_profile :mkdirp yes
  if command -v "figlet" &> /dev/null  ; then
      if command -v "lolcat" &> /dev/null  ; then
  	figlet -lt "$HOSTNAME at your service" | lolcat -F 0.3
      else
  	figlet -lt "$HOSTNAME at your service"
      fi
  else
      echo -e "$HOSTNAME at you service\\n"
  fi

#+end_src
* Bashrc
This is the main configuration file

This file has to quit for noninteractive shells
It also has to be reentrant in the sense that it has to know if it has been sourced already

** Wrapper in HOME
*** Intro
Some info at the start of the file

#+begin_src shell :tangle ~/.bashrc :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bashrc
  #

  #
  # This is the calling wrapper for .bashrc
  # The actual bashrc resides in etc/bash
  #

#+end_src
*** Call bashrc

#+begin_src shell :tangle ~/.bashrc :mkdirp yes

  #
  # Do nothing
  # except call bashrc if it exists
  #
  if [[ -f "${HOME}/etc/bash/bashrc" ]] ; then
      source "${HOME}/etc/bash/bashrc"
  fi

#+end_src
** Intro
After the intro section we are sure that bashrc has not been invoked before and that we are interactive

*** Boilerplate

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bashrc
  # 

#+end_src

*** Interactive
Only shells run by the user (interactive) should source .bashrc

This quits if the shell is not interactive

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # If not running interactively, don't do anything
  #
  if [[ "$-" != *i* ]] ; then
    # We are being invoked from a non-interactive shell.  If this
    # is an SSH session (as in "ssh host command"), source
    # /etc/profile so we get PATH and other essential variables.
    [[ -n "$SSH_CLIENT" ]] && source /etc/profile

    # Don't do anything else.
    return
  fi

#+end_src
*** .config symlink

#+begin_src shell
  #
  # Make a .config symlink if it doesnt exist
  #
  if [[ ! -L $HOME/.config ]] ; then
      ln -s $HOME/etc $HOME/.config
  fi
#+end_src
*** Debug Echo
For debugging purposes
Just knowing which file is sourced and when is usually all that is needed to debug bash startup and finish stuff

The echo goes before both the interactive check and the reentrance check so that we know what's going on

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Tell the world we are alive
  #
  echo ".bashrc sourced"

#+end_src

*** Reentance
Since .bashrc can be called from many sources even multiple times set the variable USER_BASHRC and check if set here at the beginning of bashrc
This also means that it will not be called in child bash processes.

This is done multiple times in the bashrc hierarchy, the system bashrc (usually) do something like this.

This all is a byproduct of the idiotic login shell distinction.

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Check that we haven't already been sourced.
  #
  if [[ -z ${USER_BASHRC} ]] ; then
      USER_BASHRC="1"
  else
      return
  fi

#+end_src

The reason for this is so that we can save things with preexisting commands and utilities
*** GUIX Stuff
#+begin_src shell :tangle ./bash_profile :mkdirp yes
  # #######
  # #
  # # GUIX Stuff
  # #

  # # Set up Guix Home profile

  # export GUIX_PROFILE=${HOME}/.guix-profile

  # # Merge search-paths from multiple profiles, the order matters.
  # eval "$(guix package --search-paths \
  #             -p $HOME/etc/guix/current \
  #             -p $HOME/.guix-home/profile \
  #             -p $HOME/.guix-profile \
  #             -p /run/current-system/profile)"

  # # Prepend setuid programs.
  # export PATH=/run/setuid-programs:$PATH


#+end_src
*** tmp directory
This creates some problems under both termux and guix
#+begin_src shell

  touch /tmp/$BASHPID &> /dev/null
  chmod 755 /tmp/$BASHPID &> /dev/null

  if [[ -x /tmp/$BASHPID ]] ; then
      export TMP=/tmp
      rm -f /tmp/$BASHPID
  else
      export TMP=$HOME/opt/tmp
  fi
  export TEMP=$TMP
#+end_src
*** Termux hostname
#+begin_src shell

  if [[ $HOSTNAME = "localhost" ]] ; then
      export HOSTNAME="Android"
  fi
  
#+end_src
** Path
Set the path

Since bash can be called from windows in msys2 (i.e. inside a cmd prompt) this sanity check needs to be done
Also, add the current directory to the end of the path. (this is unsafe if you dont pay attention)

#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Check path sanity
  #
  if ! echo $PATH | grep "usr/bin" > /dev/null ; then
      export PATH=$PATH:/usr/bin
  fi

  if ! echo $PATH | grep "usr/local/bin" > /dev/null ; then
      export PATH=$PATH:/usr/local/bin
  fi

  if ! echo $PATH | grep "$HOME/bin" > /dev/null ; then
      export PATH=$HOME/bin:$PATH
  fi

  export PATH=$PATH:.

#+end_src
** XDG Directories
#+begin_src shell :tangle ./bashrc :mkdirp yes
  #      Where user-specific configurations should be written (analogous to /etc).
  #      Should default to $HOME/.config.
  export XDG_CONFIG_HOME=$HOME/etc

  #      Where user-specific non-essential (cached) data should be written (analogous to /var/cache).
  #      Should default to $HOME/.cache.
  export XDG_CACHE_HOME=$HOME/opt/cache

  #      Where user-specific data files should be written (analogous to /usr/share).
  #      Should default to $HOME/.local/share.
  export XDG_DATA_HOME=$HOME/share

  #      Where user-specific state files should be written (analogous to /var/lib).
  #      Should default to $HOME/.local/state.
  export XDG_STATE_HOME=$HOME/opt/state

#+end_src
** Source helper files
Load the content of the helper files

*** Source options
#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Options
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/options" ]] ; then
      source "${XDG_CONFIG_HOME}/bash/options"
  fi

#+end_src

*** Source functions
#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Functions
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/functions" ]] ; then
      source "${XDG_CONFIG_HOME}/bash/functions"
  fi

#+end_src

*** Source aliases
#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Aliases
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/aliases" ]] ; then
      source "${XDG_CONFIG_HOME}/bash/aliases"
  fi

#+end_src

*** Source completions
#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Completions are sourced automatically from .bash_completions 
  # But we are not using that so we source manually from etc/bash
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/completions" ]] ; then
      source "${XDG_CONFIG_HOME}/bash/completions"
  fi

  # Get completions from diretory as well
  if [[ -d  "${XDG_CONFIG_HOME}/bash/completions.d" ]] ; then
      for COMP_FILE in "${XDG_CONFIG_HOME}/bash/completions.d/*" ; do
          source $COMP_FILE
      done
  fi



#+end_src

** dircolours
This needs to be done before we do exa or ls

#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Use the terminal colours set in etc/bash/dircolours
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/dircolours" ]] ; then
      eval "$(dircolors -b ${XDG_CONFIG_HOME}/bash/dircolours)"
  fi
#+end_src


** Program settings
*** Emacs shell-mode

Emacs shell needs some help in not being braindead

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Deal with emacs shell sometimes being stupid with colours
  #
  if [ -n "$INSIDE_EMACS" ] && [ -z "$ESHELL" ]; then
      #
      # Setting TERM to vt100 seems to remove most of the problems
      #
      export TERM=vt100

      #
      # Changing the colour to always fixes stuff too
      # but can screw with redirection
      #
      export COLOUR="always"
  fi

#+end_src

**** TODO Check if this has to do with dircolors not being setup to accept emacs as TERM

*** Rust

#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Setting up rust toolchain
  #
  export CARGO_HOME="$HOME/opt/rust/cargo"
  export RUSTUP_HOME="$HOME/opt/rust/rustup"
  export CARGO_BUILD_JOBS=8
  export CARGO_TARGET_DIR="$HOME/opt/rust/cargo/target"
  export RUST_BACKTRACE=1
  # export RUSTC_WRAPPER='sccache cargo install {package}'

  export PATH=$PATH:$CARGO_HOME/bin
#+end_src
*** less
#+begin_src shell :tangle ./bashrc :mkdirp yes
  
    #
    # I dont need history in less
    #  Setting the histfile to /dev/null fixes this
    #

    export LESSHISTFILE=/dev/null

#+end_src

*** vim
#+begin_src shell :tangle ./bashrc :mkdip yes
  #
  # Telling vim to load from etc/vim
  #

  export VIMINIT="source ~/etc/vim/vimrc"
  
#+end_src

*** Man
#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Set manpath
  #
  if [[ ! -z $MANPATH ]] ; then
      export MANPATH=${MANPATH}:
  fi
  export MANPATH=$MANPATH${HOME}/share/man
  export MANPAGER=less
  
#+end_src

*** GNU Readline
#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Readline config file
  #
  export INPUTRC=$XDG_CONFIG_HOME/readline/inputrc

#+end_src

*** Mozilla

#+begin_src shell :tangle ./bashrc :mkdirp yes
    #
    # Mozilla config directry
    #
  export MOZILLA_HOME=$XDG_CONFIG_HOME/mozilla
  export MOZ_PROFILE=$MOZILLA_HOME

#+end_src

*** mail
Just to keep gnus from littering all over the place

#+begin_src shell :tangle ./bashrc :mkdirp yes
  export MAILDIR=$HOME/etc/emacs/gnus/mail
#+end_src
*** exa
#+begin_src shell :tangle ./bashrc :mkdirp yes

    export EXA_OPTIONS='-lBuh --git --no-permissions --group-directories-first -I #* -I .#* -I *~' 
    export EXA_COLORS='da=1,35
  '
#+end_src
*** zoxide
#+begin_src shell :tangle ./bashrc :mkdirp yes
  if command -v zoxide $> /dev/null ; then
    eval "$(zoxide init --cmd cd bash)"
  fi
#+end_src
** Prompt
*** Static prompt
This is the static part of setting the prompt
Prompt command function adds more glam

#+begin_src shell :tangle ./bashrc :mkdirp yes


  #
  # Set the prompt (This seems to screw up xterm sometimes) 
  #
  # case $TERM in
  #     xterm*)
  #         export PS1='\[\033]0;xterm: \w\007\]\e[0m'
  #         ;;
  #     *)
  #         export PS1='\e[0m'
  #         ;;
  # esac

  # Start with a fresh prompt
  export PS1='\e[0m'

  # HH:MM bright yellow 
  PS1=$PS1'\[\e[01;33m\]\A '

  # Hostname in rainbow colours
  PS1=$PS1$(colourise_string_escaped $HOSTNAME)

  # Working directory"
  PS1=$PS1' \[\e[33m\]\w\[\e[0m\]'

  #Use __git_ps1 if we have it
  if [[ -f /usr/lib/git-core/git-sh-prompt ]] ; then
      source /usr/lib/git-core/git-sh-prompt
      PS1=$PS1'\n\[\e[00;31m\]$(__git_ps1 "(%s)")\[\e[0m\]> '
  else
      # A stylish > for the actual prompt, on a new line
      PS1=$PS1'\n> '
  fi

  # Set PS0 to clear after the line our prompt was
  # Also moves the cursor down one (the B escape)
  PS0=$PS0'\e[J\e[B\e[0m'

  # Set PS2 to clean the screen below first
  PS2='\e[J\e[0m> '

  #+end_src

 
*** Clear before exec
This removes all the glitter printed after the prompt
#+begin_src shell :tangle ./bashrc :mkdirp yes
  #
  # Clear after prompt before execution
  #
  trap 'preexec' DEBUG

#+end_src
** CD Path
#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # This makes cd look for places to cd to in . and ~
  # Surprisingly useful
  #
  export CDPATH=.:~

#+end_src
  
** LD

#+begin_src shell :tangle ./bashrc :mkdirp yes

  #
  # Where ld looks for libraries
  #
  if [[ -z $LD_LIBRARY_PATH ]] ; then
      export LD_LIBRARY_PATH=$HOME/lib
  else 
      export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/lib
  fi

#+end_src

** GTK-2.0
I dont know why 2.0 cant be satisfied with the XDG directories but here we are

#+begin_src shell
  #
  # Set GTK2 rc file
  #

  #export GTK2_RC_FILES=$XDG_CONFIG_HOME/gtk-2.0

#+end_src
*** TODO How do I do this?

* Bash logout
This is a weird file, sourced only when a login shell exits

REMEMBER: I am currently not using this so the Wrapper section is empty

** Wrapper in HOME
*** Intro
Some info at the start of the file

#+begin_src shell :tangle ~/.bash_logout :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bashrc
  #

  #
  # This is the calling wrapper for .bash_logout
  # The actual bashrc resides in etc/bash
  #

#+end_src
*** Call bash_logout

#+begin_src shell :tangle ~/.bash_logout :mkdirp yes

  #
  # Do nothing
  # except call bash_logout if it exists
  #
  if [[ -f "${XDG_CONFIG_HOME}/bash/bash_logout" ]] ; then
      source "${XDG_CONFIG_HOME}/bash/bash_logout"
  fi

#+end_src
** Intro
#+begin_src shell :tangle ./bash_logout :mkdirp yes
  #!/bin/bash
  # (So even windows knows this is a bash file)
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # .bash_logout
  # 

#+end_src

** Debug
#+begin_src shell :tangle ./bash_logout :mkdirp yes
  #
  # Debug echo
  #

  echo ".bash_logout sourced"

#+end_src

** Say bye
#+begin_src shell :tangle ./bash_logout :mkdirp yes
  #
  # Well, bye then
  #

  echo " "
  echo "bye, bye..."
  sleep 1s


#+end_src

* Options
Options is for setting things like no clobber and other bash behaviour and options
What and how to store history is also set here

Options is tangled to [[file:options][options]]

** Intro
#+begin_src shell :tangle ./options :mkdirp yes
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # Options
  # 

#+end_src

** Debug
#+begin_src shell :tangle ./options :mkdirp yes
  #
  # Debug echo
  #

  echo "options sourced"

#+end_src

** History

*** Write to disk
# Whenever displaying the prompt, write the previous line to disk
export PROMPT_COMMAND="history -a"

Except we do this in the [[prompt_command]]

*** Append to history
Make bash append rather than overwrite the history on disk

#+begin_src shell :tangle ./options :mkdirp yes
  #
  # Make bash append rather than overwrite the history on disk
  #
  shopt -s histappend

#+end_src
*** History options
Tune behaviour of bash history

#+begin_src shell :tangle ./options :mkdirp yes
  #
  # History Options
  #
  # Don't put duplicate lines in the history.
  export HISTCONTROL=$HISTCONTROL${HISTCONTROL+,}ignoredups


  # Ignore some controlling instructions
  # HISTIGNORE is a colon-delimited list of patterns which should be excluded.
  # The '&' is a special pattern which suppresses duplicate entries.
  #export HISTIGNORE=$'[ \t]*:&:[fb]g:exit'
  export HISTIGNORE=$'[ \t]*:&:[fb]g:exit:ls:cd:ps' # Ignore the ls command as well

  #
  # Store history file in etc directory
  #
  export HISTFILE=~/etc/bash/bash_history


#+end_src
** Spelling aid for cd
for example, cd /vr/lgo/apaache would find /var/log/apache

#+begin_src shell :tangle ./options :mkdirp yes
  #
  # When changing directory small typos can be ignored by bash
  #
  shopt -s cdspell

#+end_src

* Functions
Functions are more complex behaviour that can be included in the shell

Functions are tangled to [[file:functions][functions]]

** Intro
#+begin_src shell :tangle ./functions :mkdirp yes
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # Functions
  # 

#+end_src

** Debug
#+begin_src shell :tangle ./functions :mkdirp yes
  #
  # Debug echo
  #

  echo "functions sourced"

#+end_src

** do_nothing
Does nothing

#+begin_src shell :tangle ./functions :mkdirp yes
  function do_nothing ()
  {
    NOTHING_meh=" ";
  }
#+end_src

** Prompt Command
This are the functions that are called by the prompt_command functions, which in turn is called by bash every time the prompt returns

*** settitle
Set title of xterm

I'm using the PS1 method under [[Prompt]] instead since this doesnt work properly in mintty

#+begin_src shell :tangle ./functions :mkdirp yes
  # #
  # # Set title of an xterm
  # # 
  # settitle () 
  #  { 
  #    echo -ne "\[\033]0;\u@\w\007;\]" 
  #  }
  # NOTE: I'm not using this method
  function settitle()
  {
      do_nothing
  }

#+end_src
**** TODO Doesnt work with mintty, seems to be echo giving problems again
This is a bug in mintty or echo
For echo specifically echo -e which really doesnt work in mintty
Report it at some point

*** ansi_heart
Prints a red heart by coloring the background differntly and printing spaces

#+begin_src shell :tangle ./functions :mkdirp yes
  #
  # Print a crude ansi art heart
  #
  function ansi_heart ()
  {
      echo -e "\e[00m \e[00m \e[41m \e[41m \e[00m \e[00m \e[00m \e[41m \e[41m \e[00m";
      echo -e "\e[00m \e[41m \e[41m \e[41m \e[41m \e[00m \e[41m \e[41m \e[41m \e[41m \e[00m";
      echo -e "\e[00m \e[00m \e[41m \e[41m \e[41m \e[41m \e[41m \e[41m \e[41m \e[00m";
      echo -e "\e[00m \e[00m \e[00m \e[41m \e[41m \e[41m \e[41m \e[41m \e[00m";
      echo -e "\e[00m \e[00m \e[00m \e[00m \e[41m \e[41m \e[41m \e[00m";
      echo -e "\e[00m \e[00m \e[00m \e[00m \e[00m \e[41m \e[00m";
      echo " "

      # echo " A heart!!"

  }

#+end_src

*** affirmations

#+begin_src shell :tangle ./functions :mkdirp yes
  #
  # Affirmations
  #

  if [[ -f "${HOME}/share/affirmation/affirmations.txt" ]] ; then
      function affirmation ()
      {
          shuf -n 1 ${HOME}/share/affirmation/affirmations.txt;
      }
      function affirmations ()
      {
          if [[ -z $NOAFFIRMATIONS ]] ; then
              echo -en "\n\e[00;31m";
              echo -n $(affirmation)
              echo -en "\e[0m";
          else
              unset NOAFFIRMATIONS
          fi
      }
  else

      function affirmations ()
      {
          # echo "Nothing for you"
          do_nothing
      }

      function affirmation ()
      {
          # echo "Nothing for you"
          do_nothing
      }
  fi


#+end_src

*** ROOTPID
ROOTPID is used by both lolcows and runtime

#+begin_src shell :tangle ./functions :mkdirp yes
#
# Setup variables used by functions (lolcows and runtime)
#
export ROOTPID=$BASHPID

#+end_src
*** lolcows
#+begin_src shell :tangle ./functions :mkdirp yes
  if command -v cowsay &> /dev/null  && command -v lolcat &> /dev/null ; then
      function create_lolcow ()
      {
  	local lolcow_file="$TMP/$USER.lolcow.$ROOTPID"
  	
  	# Print an affirmation in a lolcow or sometimes a heart
  	if [[ 0 = `shuf -i 0-24 -n 1` ]] ; then
              ansi_heart > $lolcow_file
  	else
  	    affirmation | cowsay | lolcat -f -F 0.2 > $lolcow_file
  	fi

      }
  else
      function create_lolcow ()
      {
  	ansi_heart > $lolcow_file
      }
  fi 

      function display_lolcow () {
  	#stuff
  	local lolcow_file="$TMP/$USER.lolcow.$ROOTPID"

  	echo -en "\e[J\n\n\n\n" 

  	if [[ -f $lolcow_file ]] ; then 
              local lolcow_len=$(wc -l ${lolcow_file} | cut -f1 -d' ')
              cat $lolcow_file
              echo -en "\e["
              echo -en $lolcow_len
              echo -en "A"
  	else
              ansi_heart
              echo -en "\e[7A"
  	fi

  	# Adjust where cursor is
  	# If clear was last command, add less ws at the top
  	if [[ -z $clear_set ]] ; then
              echo -en "\e[3A"
  	else
              # If clear_set is set add one less line (or do somthing else)
              unset clear_set
              echo -en "\e[4A"
  	fi



  	( create_lolcow > /dev/null & )
      }

#+end_src

*** Runtime
A set of functions to display the runtime of a command

*I have turned this off since I cant get the latency down*

#+begin_src shell :tangle ./functions :mkdirp yes
  #  #
  # # Functions to display runtime in ms
  # # 

  # function roundseconds (){
  #     # rounds a number to 3 decimal places
  #     echo m=$1";h=0.5;scale=4;t=1000;if(m<0) h=-0.5;a=m*t+h;scale=3;a/t;" | bc
  # }

  # function bash_getstarttime (){
  #     # places the epoch time in ns into shared memory
  #     date +%s.%N >"/tmp/${USER}.bashtime.${1}"
  # }

  # function bash_getstoptime (){
  #     # reads stored epoch time and subtracts from current
  #     local endtime=$(date +%s.%N)

  #     local starttime=$(cat /tmp/${USER}.bashtime.${1})

  #     roundseconds $(echo $(eval echo "$endtime - $starttime") | bc)
  # }


  # bash_getstarttime $ROOTPID

  # # Call starttime through PS0
  # PS0=$PS0'$(bash_getstarttime $ROOTPID)'

#+end_src

*** prompt_command
#+begin_src shell :tangle ./functions :mkdirp yes

  #
  # prompt command function
  # Called by bash upon setting the PROMPT_COMMAND variable
  #
  if [[ -z $TERM || $TERM = "emacs" || $TERM = "dumb" ]] ; then

      # If I'm ever on a non ansi terminal, I'll cry then
      export TERM=vt100

      function prompt_command ()
      {
          affirmations
          echo -e '\n'


          # # Print runtime in ms of last command
          # RUNTIME=$(bash_getstoptime $ROOTPID)
          # echo -e "\e[33mTime: \e[0m${RUNTIME}\e[31ms\e[0m"

          # Write history to disk
          history -a

      }
  else
      # Write the first lolcow to disk
      create_lolcow > /dev/null 

      function prompt_command ()
      {
          # Display an affirmation in a brightly colored cow
          # Sometimes a heart
          display_lolcow

          # # Print runtime in ms of last command
          # RUNTIME=$(bash_getstoptime $ROOTPID)
          # echo -e "\e[33mTime: \e[0m${RUNTIME}\e[31ms\e[0m"

          # Write history to disk
          history -a
      }
  fi

  export PROMPT_COMMAND="prompt_command"

#+end_src

** CD Function
This function creates an undo function for cd

I used to love this one, dont use it so much anymore

#+begin_src shell :tangle ./functions :mkdirp yes
  # This function defines a 'cd' replacement function capable of keeping, 
  # displaying and accessing history of visited directories, up to 10 entries.
  # To use it, uncomment it, source this file and try 'cd --'.
  # acd_func 1.0.5, 10-nov-2004
  # Petar Marinov, http:/geocities.com/h2428, this is public domain
  cd_func ()
  {
      local x2 the_new_dir adir index
      local -i cnt

      if [[ $1 ==  "--" ]]; then
          dirs -v
          return 0
      fi

      the_new_dir=$1
      [[ -z $1 ]] && the_new_dir=$HOME

      if [[ ${the_new_dir:0:1} == '-' ]]; then
          #
          # Extract dir N from dirs
          index=${the_new_dir:1}
          [[ -z $index ]] && index=1
          adir=$(dirs +$index)
          [[ -z $adir ]] && return 1
          the_new_dir=$adir
      fi

      #
      # '~' has to be substituted by ${HOME}
      [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

      #
      # Now change to the new dir and add to the top of the stack
      pushd "${the_new_dir}" > /dev/null
      [[ $? -ne 0 ]] && return 1
      the_new_dir=$(pwd)

      #
      # Trim down everything beyond 11th entry
      popd -n +11 2>/dev/null 1>/dev/null

      #
      # Remove any other occurence of this dir, skipping the top of the stack
      for ((cnt=1; cnt <= 10; cnt++)); do
          x2=$(dirs +${cnt} 2>/dev/null)
          [[ $? -ne 0 ]] && return 0
          [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
          if [[ "${x2}" == "${the_new_dir}" ]]; then
              popd -n +$cnt 2>/dev/null 1>/dev/null
              cnt=cnt-1
          fi
      done

      return 0
  }


#+end_src

** preexec
This function will be called after user presses enter but before command is executed

Removes the lolcow (and anything else)
#+begin_src shell :tangle ./functions :mkdirp yes
  preexec()
  {
      echo -e "\033[J"  # Clear from cursor to end of screen
  }
#+end_src

** colorise_string_escaped

A function to create an escaped string generating a rainbow color pattern
Outputs a repeating pattern that will work on all but the dumbest of terminals

Suitable for use in the prompt

#+begin_src shell :tangle ./functions :mkdirp yes
  colourise_string_escaped() {
      local input="$1"
      local ansi_colours=("\[\e[00;31m\]" "\[\e[00;32m\]" "\[\e[01;33m\]" "\[\e[00;33m\]" "\[\e[01;34m\]" "\[\e[00;34m\]" "\[\e[00;35m\]")
      local ansi_reset="\[\e[0m\]"
      local output=""
      local i=0

      if [[ $TERM = "dumb" || $COLOUR = "none" ]] ; then
  	echo $input
  	return
      fi
      
      for (( j=0; j<${#input}; j++ )); do
          letter="${input:j:1}"
          output+="${ansi_colours[i]}$letter"
          i=$(( (i + 1) % ${#ansi_colours[@]} ))  # Cycle through the color array
      done

      output+="$reset"
      echo -e "$output"
  }
#+end_src 

** ls_func

#+begin_src shell :tangle ./functions :mkdirp yes
  #
  # This strips off symlink targets, requires the alias lls to be set
  #

  ls_func() {
        /usr/bin/ls ${LS_OPTIONS} --color=always "$@" | cut -d '>' -f 1 | sed 's/ -$//'
  }

#+end_src 
* Aliases
Aliases are for simple command conversion and adding basic options to invoked programs as well as some shortcuts for common usecases and typos

As there are so many: TRY and keep them alphabetical

Aliases is tangled to [[file:aliases][aliases]]

** Intro
#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # Aliases
  # 

#+end_src

*** COLOUR
#+begin_src shell
  #
  # If colour not set set it to auto
  # This is used by the aliases to set the actual colour mode
  #
  if [[ -z $COLOUR ]] ; then
      export COLOUR="auto"
  fi

#+end_src

*** Debug
#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # Debug echo
  #

  echo "aliases sourced"

#+end_src


** cat
#+begin_src shell :tangle ./aliases :mkdirp yes
  # Trying out bat instead of cat
  alias cat='bat'
  
#+end_src

** cd
Zoxide set's up the cd aliases by itself, if on a system without use old setup

For the cd_func definition see [[CD Function]] 

#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # Fallback on cd if no zoxide
  # 
  if ! command -v zoxide $> /dev/null ; then
    #
    # cd
    #
    alias cd=cd_func

    #
    # Some classic cd aliases
    #
    alias cd..='cd ..'
    alias ..='cd ..'
    alias ...='cd ../..'
    alias ....='cd ../../..'

    #
    # cd stuff related to cd_func
    #
    alias dc='cd -'
    alias c='cd --'
    alias c1='cd -1'
    alias c2='cd -2'
    alias c3='cd -3'
    alias c4='cd -4'
    alias c5='cd -5'
    alias c6='cd -6'
    alias c7='cd -7'
    alias c8='cd -8'
    alias c9='cd -9'
  fi
#+end_src

** clear/cls

#+begin_src shell :tangle ./aliases :mkdirp yes
    #
    # More fun clear and cls
    #
    #alias clear='/usr/bin/clear.exe && affirmation | cowsay | lolcat -t -F 0.25 && NOAFFIRMATIONS=noaffirmations'
    alias cls='export clear_set="clear_set" && echo -ne "\e[H\e[J"'

  if command -v lolcat &> /dev/null ; then
      alias clear='cls  && figlet -lt "Youve got this!!!" | lolcat' 
  else
      alias clear='cls  && figlet -lt "Youve got this!!!"' 
  fi


#+end_src

** depath
Remove last element in PATH

#+begin_src shell :tangle ./aliases :mkdirp yes
alias depath='export PATH=$(echo "$PATH" | sed "s/:*[^:]*$//")'
#+end_src
** du/df
#+begin_src shell :tangle ./aliases :mkdirp yes

  #
  # Human readable output from du and df
  #
  alias df='df -h'
  alias du='du -h'

#+end_src
** emacs
#+begin_src shell :tangle ./aliases :mkdirp yes
    #
    # emacsclient
    #

  if [[ -z EMACS ]] ; then
      alias emacs='emacsclient -nw -c -a emacs'
  else
      alias emacs='emacsclient -r -a vim'
  fi
#+end_src
** eng = env | grep
#+begin_src shell :tangle ./aliases :mkdirp yes

  # An alias to find processes quickly
  alias eng='env | grep -i'

#+end_src
** grep 
Readability

I used color=always for awhile but it is completely useless when redirecting output to files, so "auto" it is even if it screwes with emacs shell mode sometimes

#+begin_src shell :tangle ./aliases :mkdirp yes

  #
  # Use colours to show grep hits
  #
  export GREP_COLORS='ms=01;31'


  # I dont trust rg (yet) for serious stuff
  #alias grep='rg --colors match:fg:magenta --color=$COLOUR'

  # alias grep='grep -THn --color=$COLOUR'

  # Making use of bat
  __grep=$(which grep)
  grep() {
      if [ -t 1 ]; then
  	# The insane sed thingy is to reliably get rid of the ANSI colours
  	$__grep -THn --color=always "$@" | sed 's/.*(standard input)[^:].m..K..36m..K:..m..K//' | bat
      else
  	$__grep --color=none "$@"
      fi
  }
  alias egrep='grep -E '
  alias fgrep='grep -F '


#+end_src
** hexdump
Old school
#+begin_src shell :tangle ./aliases :mkdirp yes
  # hexdump
  alias hexdump='hexdump -C'
  
#+end_src

** ls / ex
Set and use the variable LS_OPTIONS to change ls behaviour

=TL;DR= No superflous information and pretty

The following are the switches used

  -A, --almost-all           do not list implied . and ..
  -B, --ignore-backups       do not list implied entries ending with ~
      --color[=WHEN]         colorize the output; WHEN can be 'always' (default`
                               if omitted), 'auto', or 'never'; more info below
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -o                         like -l, but do not list group information
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow  each  command line symbolic link that points to a direc‚Äê
                             tory                        
Full documentation <https://www.gnu.org/software/coreutils/ls>

For some reason -B doesnt always work, so I added an --ignore=*~

#+begin_src shell :tangle ./aliases :mkdirp yes

  #
  # Use $LS_OPTIONS so we can change on the fly
  #
  # lss = ls without any options
  alias lls=`which ls`

  # Options as described above 
  export LS_OPTIONS="-BghoH --group-directories-first --dereference-command-line-symlink-to-dir --ignore=#* --ignore=.#* --ignore=*~"

  # Standard alias for ls
  alias ls='exa $EXA_OPTIONS'
  alias lss='ls -A $LS_OPTIONS --color=$COLOUR'

 
#+end_src
** make
#+begin_src shell :tangle ./aliases :mkdirp yes
  # Making sure make doesnt take too long
  
  alias make='make -j $(nproc)'
#+end_src
** path/rpath
#+begin_src shell :tangle ./aliases :mkdirp yes

  #win style alias to print the path
  alias path='echo $PATH'

  #rpath
  # TODO: Add old rpath 


#+end_src
** psg = ps xa | grep
#+begin_src shell :tangle ./aliases :mkdirp yes

  # An alias to find processes quickly
  alias psg='ps xa | grep -v grep | grep'

#+end_src
** rm
#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # Safe(r) rm
  #
  alias rm='rm -I'

#+end_src

** top
#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # top / htop
  #
  if command -v htop &> /dev/null ; then
      alias top=htop
  fi
#+end_src
** which
A =which= alias for old people

#+begin_src shell :tangle ./aliases :mkdirp yes
  #
  # Old utility which
  # Cause I am old
  #
  alias which='command -v'

#+end_src

* Completions
Completions places in .bash_completions are sourced automagically

Point being to keep as many of these files in etc/bash we do it manually
here.

Completions are placed in [[file:completions][completions]]

** Intro
#+begin_src shell :tangle ./completions :mkdirp yes
  #
  # OBS! Do not edit this file! Edit Bash.org
  #

  #
  # Completions
  # 
  # It contains programmatic completions for use by bash

#+end_src

** Debug
#+begin_src shell :tangle ./completions :mkdirp yes
  #
  # Debug echo
  #

  echo "completions sourced"

#+end_src

** System wide completions
#+begin_src shell :tangle ./completions :mkdirp yes
  #
  # Uncomment to turn on programmable completion enhancements.
  #

  # We trust the system-wide to do all the work for us
  if [[ -f /usr/share/bash_completion/bash_completion ]] ; then
      source /usr/share/bash_completion/bash_completion
  fi

  # Add completions installed in home directory
  if [[ -d  $HOME/share/bash-completion/completions ]] ; then
      for COMP_FILE in $HOME/share/bash-completion/completions/* ; do
          source $COMP_FILE
      done
  fi


#+end_src

* Dircolours
These are the colours that =ls= uses.

It's not an executable shell script but rather a database of sorts

Colours are given as ansi colours. Extended and truecolour sequences works if your terminal supports it. Emacs shell-mode can only do the first 8 colours, so I'm sticking to that

#+begin_src shell :tangle ./dircolours :mkdirp yes
# Configuration file for dircolors, a utility to help you set the
# LS_COLORS environment variable used by GNU ls with the --color option.
# Copyright (C) 1996-2020 Free Software Foundation, Inc.
# Copying and distribution of this file, with or without modification,
# are permitted provided the copyright notice and this notice are preserved.
# The keywords COLOR, OPTIONS, and EIGHTBIT (honored by the
# slackware version of dircolors) are recognized but ignored.
# Below are TERM entries, which can be a glob patterns, to match
# against the TERM environment variable to determine if it is colorizable.
TERM Eterm
TERM ansi
TERM *color*
TERM con[0-9]*x[0-9]*
TERM cons25
TERM console
TERM cygwin
TERM dtterm
TERM gnome
TERM hurd
TERM jfbterm
TERM konsole
TERM kterm
TERM linux
TERM linux-c
TERM mlterm
TERM putty
TERM rxvt*
TERM screen*
TERM st
TERM terminator
TERM tmux*
TERM vt100
TERM xterm*
# Below are the color init strings for the basic file types.
# One can use codes for 256 or more colors supported by modern terminals.
# The default color codes use the capabilities of an 8 color terminal
# with some additional attributes as per the following codes:
# Attribute codes:
# 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed
# Text color codes:
# 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white
# Background color codes:
# 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white
#NORMAL 00 # no color code at all
#FILE 00 # regular file: use no color at all
#FILE 01;31 # Simple test
RESET 0 # reset to "normal" color
DIR 00;34 # directory
#DIR 01;37;44 # directory test
LINK 01;36 # symbolic link. (If you set this to 'target' instead of a
 # numerical value, the color is as for the file pointed to.)
MULTIHARDLINK 00 # regular file with more than one link
FIFO 40;33 # pipe
SOCK 01;35 # socket
DOOR 01;35 # door
BLK 40;33;01 # block device driver
CHR 40;33;01 # character device driver
ORPHAN 40;31;01 # symlink to nonexistent file, or non-stat'able file ...
MISSING 00 # ... and the files they point to
SETUID 37;41 # file that is setuid (u+s)
SETGID 30;43 # file that is setgid (g+s)
CAPABILITY 30;41 # file with capability
STICKY_OTHER_WRITABLE 30;42 # dir that is sticky and other-writable (+t,o+w)
OTHER_WRITABLE 34;42 # dir that is other-writable (o+w) and not sticky
STICKY 37;44 # dir with the sticky bit set (+t) and not other-writable
# This is for files with execute permission:
EXEC 01;32
# List any file extensions like '.gz' or '.tar' that you would like ls
# to colorize below. Put the extension, a space, and the color init string.
# (and any comments you want to add after a '#')
# If you use DOS-style suffixes, you may want to uncomment the following:
.cmd 01;32 # executables (bright green)
.exe 01;32
.com 01;32
.btm 01;32
.bat 01;32
# Or if you want to colorize scripts even if they do not have the
# executable bit actually set.
.sh 01;32
.csh 01;32
 # archives or compressed (bright red)
.tar 01;31
.tgz 01;31
.arc 01;31
.arj 01;31
.taz 01;31
.lha 01;31
.lz4 01;31
.lzh 01;31
.lzma 01;31
.tlz 01;31
.txz 01;31
.tzo 01;31
.t7z 01;31
.zip 01;31
.z 01;31
.dz 01;31
.gz 01;31
.lrz 01;31
.lz 01;31
.lzo 01;31
.xz 01;31
.zst 01;31
.tzst 01;31
.bz2 01;31
.bz 01;31
.tbz 01;31
.tbz2 01;31
.tz 01;31
.deb 01;31
.rpm 01;31
.jar 01;31
.war 01;31
.ear 01;31
.sar 01;31
.rar 01;31
.alz 01;31
.ace 01;31
.zoo 01;31
.cpio 01;31
.7z 01;31
.rz 01;31
.cab 01;31
.wim 01;31
.swm 01;31
.dwm 01;31
.esd 01;31
# image formats
.jpg 00;35
.jpeg 00;35
.mjpg 00;35
.mjpeg 00;35
.gif 00;35
.bmp 00;35
.pbm 00;35
.pgm 00;35
.ppm 00;35
.tga 00;35
.xbm 00;35
.xpm 00;35
.tif 00;35
.tiff 00;35
.png 00;35
.svg 00;35
.svgz 00;35
.mng 00;35
.pcx 00;35
.mov 00;35
.mpg 00;35
.mpeg 00;35
.m2v 00;35
.mkv 00;35
.webm 00;35
.webp 00;35
.ogm 00;35
.mp4 00;35
.m4v 00;35
.mp4v 00;35
.vob 00;35
.qt 00;35
.nuv 00;35
.wmv 00;35
.asf 00;35
.rm 00;35
.rmvb 00;35
.flc 00;35
.avi 00;35
.fli 00;35
.flv 00;35
.gl 00;35
.dl 00;35
.xcf 00;35
.xwd 00;35
.yuv 00;35
.cgm 00;35
.emf 00;35
# https://wiki.xiph.org/MIME_Types_and_File_Extensions
.ogv 01;35
.ogx 01;35
# audio formats
.aac 00;36
.au 00;36
.flac 00;36
.m4a 00;36
.mid 00;36
.midi 00;36
.mka 00;36
.mp3 00;36
.mpc 00;36
.ogg 00;36
.ra 00;36
.wav 00;36
# https://wiki.xiph.org/MIME_Types_and_File_Extensions
.oga 00;36
.opus 00;36
.spx 00;36
.xspf 00;36
#Github
.md 01;37;40
.git 01;37;44
#textfiles
.txt 01;37;40
.now 01;37;44
#+end_src



* Tangle on save
Lastly, setup org babel to auto-tangle in this directory

#+begin_src emacs-lisp :tangle ./.dir-locals.el :mkdirp yes
((org-mode . ((eval . (add-to-list 'emfrom/org-babel-autotangle-dirs (file-name-directory (or load-file-name buffer-file-name)))))))
#+end_src

